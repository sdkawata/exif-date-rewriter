<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EXIF Date Rewriter</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 600px;
      margin: 2rem auto;
      padding: 0 1rem;
      background: #fafafa;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 1.5rem;
    }
    .form-group {
      margin-bottom: 1rem;
    }
    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
    }
    input[type="datetime-local"] {
      padding: 0.5rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 100%;
      max-width: 300px;
    }
    button {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    #dropzone {
      margin-top: 1rem;
      padding: 2rem;
      border: 2px dashed #ccc;
      border-radius: 8px;
      text-align: center;
      color: #666;
      transition: all 0.2s;
    }
    #dropzone.dragover {
      border-color: #007bff;
      background: #e7f1ff;
      color: #007bff;
    }
    #log {
      margin-top: 1.5rem;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 1rem;
      height: 250px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.875rem;
      line-height: 1.5;
    }
    .success { color: #28a745; }
    .error { color: #dc3545; }
    .info { color: #666; }
  </style>
</head>
<body>
  <h1>EXIF Date Rewriter</h1>

  <div class="form-group">
    <label for="newDate">書き換える日時</label>
    <input type="datetime-local" id="newDate">
  </div>

  <button id="selectDir">ディレクトリを選択して実行</button>

  <div id="dropzone">または、ここにフォルダをドラッグ＆ドロップ</div>

  <div id="log"><span class="info">ログがここに表示されます</span></div>

  <script>
    // EXIF解析・部分書き換えモジュール
    const ExifDateRewriter = (() => {
      const TAG_DATETIME_ORIGINAL = 0x9003;
      const TAG_DATETIME_DIGITIZED = 0x9004;
      const TAG_EXIF_IFD = 0x8769;

      // バイト読み取りヘルパー
      const readUint16 = (view, offset, littleEndian) => view.getUint16(offset, littleEndian);
      const readUint32 = (view, offset, littleEndian) => view.getUint32(offset, littleEndian);

      // JPEG内のAPP1(EXIF)セグメントを探す
      const findApp1Segment = (view) => {
        if (view.getUint16(0) !== 0xFFD8) return null; // Not JPEG

        let offset = 2;
        while (offset < view.byteLength - 4) {
          const marker = view.getUint16(offset);
          if (marker === 0xFFE1) { // APP1
            const length = view.getUint16(offset + 2);
            // Check "Exif\0\0"
            if (view.getUint32(offset + 4) === 0x45786966 && view.getUint16(offset + 8) === 0x0000) {
              return { offset: offset + 10, length: length - 8 }; // TIFFヘッダー開始位置
            }
          }
          if ((marker & 0xFF00) !== 0xFF00) break;
          const segmentLength = view.getUint16(offset + 2);
          offset += 2 + segmentLength;
        }
        return null;
      };

      // IFDを解析してタグのオフセットを探す
      const parseIFD = (view, tiffStart, ifdOffset, littleEndian, targetTags) => {
        const results = {};
        const entryCount = readUint16(view, tiffStart + ifdOffset, littleEndian);

        for (let i = 0; i < entryCount; i++) {
          const entryOffset = tiffStart + ifdOffset + 2 + i * 12;
          const tag = readUint16(view, entryOffset, littleEndian);
          const type = readUint16(view, entryOffset + 2, littleEndian);
          const count = readUint32(view, entryOffset + 4, littleEndian);

          if (targetTags.includes(tag)) {
            // ASCII type (2), count includes null terminator
            if (type === 2 && count === 20) {
              const valueOffset = readUint32(view, entryOffset + 8, littleEndian);
              results[tag] = tiffStart + valueOffset;
            }
          }
        }

        return results;
      };

      // ExifIFDへのポインタを取得
      const findExifIFDPointer = (view, tiffStart, ifdOffset, littleEndian) => {
        const entryCount = readUint16(view, tiffStart + ifdOffset, littleEndian);

        for (let i = 0; i < entryCount; i++) {
          const entryOffset = tiffStart + ifdOffset + 2 + i * 12;
          const tag = readUint16(view, entryOffset, littleEndian);

          if (tag === TAG_EXIF_IFD) {
            return readUint32(view, entryOffset + 8, littleEndian);
          }
        }
        return null;
      };

      // DateTimeOriginal/Digitizedのファイル内オフセットを探す
      const findDateTimeOffsets = (buffer) => {
        const view = new DataView(buffer);

        const app1 = findApp1Segment(view);
        if (!app1) return null;

        const tiffStart = app1.offset;

        // バイトオーダー確認
        const byteOrder = view.getUint16(tiffStart);
        const littleEndian = byteOrder === 0x4949; // "II"
        if (!littleEndian && byteOrder !== 0x4D4D) return null; // Not "MM" either

        // TIFF magic number check
        if (readUint16(view, tiffStart + 2, littleEndian) !== 0x002A) return null;

        // IFD0 offset
        const ifd0Offset = readUint32(view, tiffStart + 4, littleEndian);

        // Find ExifIFD pointer in IFD0
        const exifIFDOffset = findExifIFDPointer(view, tiffStart, ifd0Offset, littleEndian);
        if (!exifIFDOffset) return null;

        // Parse ExifIFD for DateTimeOriginal and DateTimeDigitized
        const offsets = parseIFD(view, tiffStart, exifIFDOffset, littleEndian, [
          TAG_DATETIME_ORIGINAL,
          TAG_DATETIME_DIGITIZED
        ]);

        // 現在の値を読み取る
        const readDateString = (offset) => {
          const bytes = new Uint8Array(buffer, offset, 19);
          return new TextDecoder('ascii').decode(bytes);
        };

        const result = { offsets: [], oldDates: [] };

        if (offsets[TAG_DATETIME_ORIGINAL]) {
          result.offsets.push(offsets[TAG_DATETIME_ORIGINAL]);
          result.oldDates.push(readDateString(offsets[TAG_DATETIME_ORIGINAL]));
        }
        if (offsets[TAG_DATETIME_DIGITIZED]) {
          result.offsets.push(offsets[TAG_DATETIME_DIGITIZED]);
        }

        return result.offsets.length > 0 ? result : null;
      };

      return { findDateTimeOffsets };
    })();

    // UI
    const logEl = document.getElementById('log');
    const logQueue = [];
    let logFlushTimer = null;

    const flushLog = () => {
      if (logQueue.length === 0) return;
      const frag = document.createDocumentFragment();
      for (const [msg, type] of logQueue) {
        const span = document.createElement('span');
        span.className = type;
        span.textContent = msg;
        frag.appendChild(span);
        frag.appendChild(document.createElement('br'));
      }
      logEl.appendChild(frag);
      logEl.scrollTop = logEl.scrollHeight;
      logQueue.length = 0;
    };

    const log = (msg, type = '') => {
      logQueue.push([msg, type]);
      if (!logFlushTimer) {
        logFlushTimer = setInterval(flushLog, 50);
      }
    };

    const clearLog = () => {
      logQueue.length = 0;
      logEl.innerHTML = '';
    };

    const stopLogFlush = () => {
      flushLog();
      if (logFlushTimer) {
        clearInterval(logFlushTimer);
        logFlushTimer = null;
      }
    };

    const formatExifDate = (date) => {
      const d = new Date(date);
      const pad = n => String(n).padStart(2, '0');
      return `${d.getFullYear()}:${pad(d.getMonth()+1)}:${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    };

    const btn = document.getElementById('selectDir');
    const dropzone = document.getElementById('dropzone');
    let isProcessing = false;

    const CONCURRENCY = 10;

    const processDirectoryHandle = async (dirHandle) => {
      const dateInput = document.getElementById('newDate').value;
      if (!dateInput) {
        alert('日時を指定してください');
        return;
      }

      if (isProcessing) return;
      isProcessing = true;

      const exifDate = formatExifDate(dateInput);
      const exifDateBytes = new TextEncoder().encode(exifDate);

      clearLog();
      log(`設定する日時: ${exifDate}`, 'info');

      btn.disabled = true;
      btn.textContent = '処理中...';
      dropzone.textContent = '処理中...';

      const startTime = performance.now();

      try {
        let processed = 0;
        let skipped = 0;
        let failed = 0;

        // ファイルを全て収集
        const files = [];
        const collectFiles = async (dirHandle, path = '') => {
          for await (const entry of dirHandle.values()) {
            const entryPath = path ? `${path}/${entry.name}` : entry.name;
            if (entry.kind === 'directory') {
              await collectFiles(entry, entryPath);
            } else if (entry.kind === 'file' && /\.jpe?g$/i.test(entry.name)) {
              files.push({ entry, path: entryPath });
            }
          }
        };
        await collectFiles(dirHandle);
        log(`対象ファイル: ${files.length}件`, 'info');

        // 並列処理用セマフォ
        const semaphore = {
          count: CONCURRENCY,
          queue: [],
          acquire() {
            return new Promise(resolve => {
              if (this.count > 0) { this.count--; resolve(); }
              else { this.queue.push(resolve); }
            });
          },
          release() {
            if (this.queue.length > 0) { this.queue.shift()(); }
            else { this.count++; }
          }
        };

        const HEADER_SIZE = 65536; // 64KB

        const processFile = async ({ entry, path: entryPath }) => {
          await semaphore.acquire();
          try {
            const file = await entry.getFile();
            const headerBuffer = await file.slice(0, HEADER_SIZE).arrayBuffer();
            const result = ExifDateRewriter.findDateTimeOffsets(headerBuffer);

            if (!result || result.offsets.length === 0) {
              skipped++;
              log(`- ${entryPath}: EXIFなし`, 'info');
              return;
            }

            const oldDate = result.oldDates[0] || '(不明)';
            const writable = await entry.createWritable({ keepExistingData: true });
            for (const offset of result.offsets) {
              await writable.seek(offset);
              await writable.write(exifDateBytes);
            }
            await writable.close();

            processed++;
            log(`✓ ${entryPath}: ${oldDate} → ${exifDate}`, 'success');
          } catch (e) {
            failed++;
            log(`✗ ${entryPath}: ${e.message}`, 'error');
          } finally {
            semaphore.release();
          }
        };

        await Promise.all(files.map(processFile));

        const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
        log(`完了: ${processed}件成功, ${skipped}件スキップ, ${failed}件失敗 (${elapsed}秒)`, 'info');
      } catch (e) {
        log(`エラー: ${e.message}`, 'error');
      } finally {
        stopLogFlush();
        isProcessing = false;
        btn.disabled = false;
        btn.textContent = 'ディレクトリを選択して実行';
        dropzone.textContent = 'または、ここにフォルダをドラッグ＆ドロップ';
      }
    };

    // ボタンクリック
    btn.addEventListener('click', async () => {
      try {
        const dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
        await processDirectoryHandle(dirHandle);
      } catch (e) {
        if (e.name !== 'AbortError') {
          log(`エラー: ${e.message}`, 'error');
        }
      }
    });

    // ドラッグ＆ドロップ
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.classList.add('dragover');
    });

    dropzone.addEventListener('dragleave', () => {
      dropzone.classList.remove('dragover');
    });

    dropzone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropzone.classList.remove('dragover');

      const items = [...e.dataTransfer.items];
      for (const item of items) {
        const handle = await item.getAsFileSystemHandle();
        if (handle && handle.kind === 'directory') {
          await processDirectoryHandle(handle);
          break;
        }
      }
    });
  </script>
</body>
</html>
